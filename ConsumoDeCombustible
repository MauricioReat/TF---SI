#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <map>

struct vehicleData{
//puedes agregar las caracteristicas
    std::string vehicleID;
    std::string date;
    double fuel Consumed
};

//Funcion para cargar los datos CSV
std::vector<VehicleData> loadData(const std::string& filename){
    std::vector<VehicleData>data;
    std::ifstream file (filename);
    if (!file.is_open()){
        std::cerr << "Could not open the file" << filename << std::endl;
        return data;
    }

    std::string line;
    while (std::getline(file, line()){
        std::stringstream ss(line);
        vehicleData entry;
        std::string fuelStr;

        std::getline(ss, entry.vehicleID, "," );
        std::getline(ss, entry.date, ",");
        std::getline(ss, fuelStr, ",");

        try{
            entry.fuelConsumed = std::stod(fuelStr);
        } catch (const std ::invalid_argument& e){
            std::cerr << "Invalid data format: " << line << std::endl;
            continue;
        }

        data.push_back(entry);

    }

    file.close();
    return data ;
}

    //Funcion para Calcular la Distancia
    double euclideanDistance(const VehicleData& a, const VehicleData& b){
        double diffFuel = a.fuelConsumed - b.fuelConsumed;
        return std::sqrt(diffFuel * diffFuel);
    }

    std::string knn(const std::vector<VehicleData>& data, const vehicleData& query, int k){
        std::vector<std::pair<double, std::string>> distances;

        for(const auto& entry : data){
            double dist = euclideanDistance(entry, query);
            distance.push_back(std::make_pair(dist, entry.vehicleID));
        }

        std::sort(distances.begin(), distances.end());

        std (int i=0; i; ++1){
            countMap[distances[i].second]++;
        }

        std::string bestMatch;
        int maxCount = 0;
        for(const auto% pair : counMap){
            if(pair.second > macCount){
                maxCount = pair.second;
                bestMatch = pair.first;
            }
        }

        return bestMatch

    }
