#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <map>

using namespaces std;

struct vehicleData{
//puedes agregar las caracteristicas
    string vehicleID;
    string date;
    double fuel Consumed
};

//Funcion para cargar los datos CSV
vector<VehicleData> loadData(const string& filename){
    vector<VehicleData>data;
    ifstream file (filename);
    if (!file.is_open()){
        cerr << "Could not open the file" << filename;
        return data;
    }

    string line;
    while (getline(file, line()){
        stringstream ss(line);
        vehicleData entry;
        string fuelStr;

        getline(ss, entry.vehicleID, "," );
        getline(ss, entry.date, ",");
        getline(ss, fuelStr, ",");

        try{
            entry.fuelConsumed = std::stod(fuelStr);
        } catch (const invalid_argument& e){
            cerr << "Invalid data format: " << line;
            continue;
        }

        data.push_back(entry);

    }

    file.close();
    return data ;
}

    //Funcion para Calcular la Distancia
    double euclideanDistance(const VehicleData& a, const VehicleData& b){
        double diffFuel = a.fuelConsumed - b.fuelConsumed;
        return sqrt(diffFuel * diffFuel);
    }

    string knn(const vector<VehicleData>& data, const vehicleData& query, int k){
    vector<pair<double, string>> distances;

        for(const auto& entry : data){
            double dist = euclideanDistance(entry, query);
            distance.push_back(std::make_pair(dist, entry.vehicleID));
        }

        sort(distances.begin(), distances.end());

        std (int i=0; i; ++1){
            countMap[distances[i].second]++;
        }

        string bestMatch;
        int maxCount = 0;
        for(const auto% pair : counMap){
            if(pair.second > macCount){

                maxCount = pair.second;
                bestMatch = pair.first;

            }
        }

        return bestMatch

    }
